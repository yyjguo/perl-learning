#!/usr/bin/perl
use strict;
use warnings FATAL => 'all';

#不要把正则表达式和shell的文件名匹配模式混为一谈
#\p{Space} 匹配包含
#\P{Space} 匹配不包含
#元字符 . \ * ? ()


=pod 1 简单的量词
*是用来匹配前面的条目的零次或多次的,前面的东西可以重复任意次

.匹配任意字符 除了换行符之外
+匹配前一个条目一次以上,算上刚才出现的,再加上任意次重复
?表示前一个条目可有可无,只会出现一次
. + ? 必须接在某个东西之后

.*匹配任意字符无限多次

=cut
#模式分组,圆括号(),对字符串分组

=pod 2 模式分组
()小括号的作用是对字符串分组
因此圆括号也是元字符
圆括号使得重新使用某些字符串成为可能.
反向引用:引用圆括号中的模式所匹配的文字,也称为捕获组;
反向引用:在反斜线的后面接上数字编号,\1 \2.相应的数字表示对应顺序的捕获组
/(.)\1/表示需要匹配连续出现俩个同样的字符
\g{N},其中N是要反向引用的组号,这样在模式中加入更多的内容,就不必修改反向引用的的编号了.因为要加入另一个捕获组,就会导致所有的绝对编号的反向引用失效,而相对引反向引用则不会,因为他的使用时相对于自己的位置,而不是绝对编号,所以维护起来很轻松.
Perl会尽可能创建多的反向引用.

=cut

=pod 2 择一匹配
竖线 | 通常可以读成或
/fred(|\t)+barney/ 这样的模式来匹配fred 和 barney之间出现的一次以上空格 制表符 或俩者混合的字符串
在正则表达式里and和or这俩个词并不是操作符,因为他们是字符串的一部分

=cut

#字符集:指的是一组可能出现的字符,通过在方括号内表示,它只匹配单个字符,但可以是字符集中的列出的任何一个


=pod 4 模式匹配
默认情况下,模式匹配的操作对象是$_,绑定操作符=~告诉perl,拿右边的模式匹配左边的字符串,而不是匹配$_

=cut

=pod 5 grep
全局搜索正则表达式并打印
文件名通配
=cut

#使用简单的模式
$_ = "yabba dabba doo";
if (/abba/) {
    print "It matched!\n";
}

#/cake\tsprite/ 匹配coke 一个制表符 sprite


#模式匹配用来返回真值和假值.

=pod 6 Unicode属性
每个属性都有一个名字,完整的清单在Perluniprops文档中.
匹配某项属性,把属性名放在p\{PROPERTY}里面
把小写p变成大写,就表示否定意义,匹配指定属性以为的字符
=cut

if (/\p{Space}/) { #总共有26个不同的字符带此属性,空白字符
    print "The string has some whitespace.\n";

}
if (/\p{Digit}/) {#总共有411个不同的数字字符
    print "The string has a digit.\n";

}
if (/\P{Space}/) {#只要不是空白符都能匹配 ,自然不计其数
    print "The string has one or more non-whitespace characters.\n";
}

=pod 7 关于元字符
模式只能匹配简单的直接量,实际用处不大
引入特殊字符,称为元字符,它在正则表达式中有特殊的含义.
在任何元字符前面加上反斜线,就会使他失去元字符的作用.
反斜线是第二个元字符,若要匹配真正的反斜线,请用俩个反斜线来表示
加号在表示俩个名词之间必须有一个以上的空格
=cut

=pod 字符集
character class
指的是一组可能出现的字符,通过写在方括号[]内表示,它只匹配单个字符,单可以是字符集中列出的任何一个.
比如字符集[abcdefg],它可以匹配7个字符中的任意一个.可以用连字符-表示始末范围,这样之前的字符集可以改为[a-g];
[\000-\177]将会匹配任意一个7位的ASCII字符,
在字符集开头的地方加上脱字符^,来表示这些字符除外.
[^des]会匹配这三个字除外的任何字符,
/HAL-[0-9]+/里的第一个连字符则不需要反斜线,因为字符集括号外面的连字符没有特殊意义

字符集简写:
一个数字的字符简写是\d,那么/HAL-[0-9]+/可以简写成/HAL-\d+/这样的形式,严格按照ascii的范围来匹配数字字符是,可以选用修饰符/a,写在正则表达式末尾,同样的,\s简写能匹配任意空白符,效果等同于Unicode属性\p{Space},在ASCII语义下,\w匹配的是这样一组字符[a-zA-Z0-9_].一个好的正则模式应当仅仅匹配需要的那些字符,不留一点多余.很多情况下,特别是将来写新代码的时候,应当尽量选用范围明确,可维护性好的模式来定义字符集,避免一味采用简写带来预期之外的效果
反义简写: [^\d]于\D,大写版本能匹配相应小写版本范围以外的字符.
[\d\D],表示任何数字或非数字.也就是说匹配任意字符
[^\d\D],匹配既不是数字也不是非数字,什么都不匹配
=cut

if (/HAL-[\d]+/) {
    say "The string mentions some model of HAL computer";
}

if (/HAL-[\d]+/a) { #按老的ascii字符语义解释
    say "The string mentions some model of HAL computer";
}

=pod 用正则表达式进行匹配
上面的内容对正则表达式有了一个大概的了解,如何融入Perl世界.
用m//进行匹配,可以选任何成对的定界符,如m(fred) m<fred> m{fred} m[fred],或者可以使用其他不成对定界符来改写成m,fred,
 m!fred!  m^fred^等
在匹配常规的网址的时候,可能会用/http:\/\//来匹配起始的"http://",其实可以选择更好的定界符,如:m%^http://%
=cut

=pod 模式匹配修饰符
Perl有好几个模式匹配的修饰符,有时候也叫标志,他们是一些追加在模式表达末尾定界符后面的字母,用来改变默认的匹配行为.
用/i进行大小写无关的模式匹配,比如同时匹配REND rend 和 Rend,可以用/i修饰符;
用/s匹配任意字符,点号.无法匹配换行符,这对大多数单行匹配的情况是合适的./s修饰符可以匹配这些换行符.我们只想几个点号匹配任意字符呢?可以换用[^\n],或者\N
用/x加入空白符,允许我们在模式里面随意加上空白符从而使他更易阅读理解   /-?[0-9]+\.?[0-9]*/  #都挤在一起,很难看清是什么意思
    / -? [0-9]+ \.? [0-9]* /x  #加入空白好多了
所以原来表示空白和制表符本身的空白就失去了意义,Perl会直接忽略.
Perl还会把模式中出现的注释当做空白直接忽略掉,所以要表示井号本身,就得写成\#,或者使用其他字符集[#],注释部分不要使用定界符,否则会被视为模式终点.

组合选项修饰符:
对单次匹配使用多项修饰符,只需要把他们接在一起写在模式末尾(不用在意顺序);

选择一种字符解释方式:
总共有三种字符解释方式: ASCII Unicode locale
/a 告诉Perl采用ASCII方式
/u 告诉Perl采用Unicode方式
/l 告诉Perl采用locale方式
/aa 进一步表示仅仅采取ASCII方式的大小写映射处理

在perl5里面可以用$锚位和/m修饰符表示对多行内容进行匹配.
/fred$/m 会匹配所有的给定字符串中所有的fred以及随后出现的换行符,或者是字符串绝对末尾位置上的fred.

单词边界锚位\b,/\bhunt/匹配以hunt开头的单词
非单词边界锚位\B,它能匹配所有\b不能匹配的位置

绑定操作符: 默认情况下匹配的操作对象是$_,绑定操作符=~,告诉Perl,拿右边的模式来匹配左边的字符串,而不是$_.

模式中的内插,正则表达式内部可以进行双引号形式的内插,这样我们就可以很快写成下面这样类似grep命令的程序.

捕获变量: 圆括号出现的地方一般都会触发正则表达式引擎捕获匹配到的字符串.捕获变量通常能活到下次成功为止.

不捕获模式: 目前所见的圆括号都会捕获部分的匹配字符串到捕获变量中,但是有时候需要关闭这个功能,而仅仅是只用它来分组.需要在左括号的后面加上问号和冒号(?:),告诉Perl这一对圆括号完全是为了分组而存在的.

命名捕获: 最终捕获到的内容会保存在特殊哈希%+里面:其中的键就是在捕获的时用的特殊标签,对应的值是被捕获的字符串,具体的写法是(?<lable>pattern),使用捕获标签之后,反向引用的用法也随之变化,之前我们用\1或者\g{1}这样的写法,现在可以用\g{lable}这样的写法

自动捕获变量: $& $` $' 字符串里实际匹配模式的部分会被自动存进$&里

通用量词: 代表前面条目的重复次数.我们已经见过三个量词:* + ?,如果这三个量词都不符合需求,你还可以使用花括号{}的形式来指定具体的重复次数范围.模式/a{5,15}/可匹配重复出现5到15次的字母a.如果省略第二个数字但保留逗号,则表示匹配次数没有上限.如果只有第一个数字,会匹配与数字值相同次数.

=cut

print "would you like to play a game?";
chomp($_ = <STDIN>);
if (/yes/i) {
    print "In that case, I recommend that you go bowling.\n";
}
#如果没有/s修饰符的话,上面的匹配就会失败,因为前后俩个名字并不在同一行
$_ = "I saw Barney\ndown at the bowling alley\nwith Fred\nlast night.\n";
if (/Barney.*Fred/s) {
    print "That string mentions Fred after Barney!\n";
}
#组合选项修饰符
if (/barney.*fred/is) {
    print "That string mentions Fred after Barney!\n";
}

my $some_other = "I dream of betty rubble.";
if ($some_other =~ /\brub/) {
    print "Aye, there is the rub.\n";
}

print "Do you like perl?";
my $like_perl = <STDIN> =~ /\byes\b/i;

my $what = "larry";
while (<>) {
    if (/\A($what)/) {
        print "We saw $what in beginnig of $_";
    }
}
#匹配失败,他会输出之前遗留在$1里的字符串
my $wilma = "123";
$wilma =~ /[0-9]+/; #匹配成功$1的内容是123
$wilma =~ /[a-zA-Z]+/; #错了,这里没有判断匹配结果是否成功
print "Wilma is word was $1... or was it?\n";#所以捕获变量$1的内容依旧是123

if (/(?:bronto)?saurus(?:bbo)?(steak|burger)/) {
    print "Fred wants a $1\n";
}

my $names = "fred or barney";
if ($name =~ m/(?<name1>\w+)(?:and|or)(?<name2>\w+)/) {

    say "I saw $+{name1} and $+{name2}";
}
#第一个捕获的内容是$1,具有5个单词的there,但是$&里保存的是整个匹配区段;匹配区段之前的内容会保存在$`中,匹配区段之后的内容会保存到$'中.如果将这三个字符串依次连接起来,就一定会得到原来的字符串.一般而言,他们的值会一直持续到下一次模式匹配成功之前
if ("Hello there, neighbor" =~ /\s(\w+),/) {
    print "That actually matched '$&'.\n";
}
if ("Hello there, neighoor" =~ /\s(\w+),/) {
    print "That was ($`)($&)($').\n";#程序运行时会把这三个自动捕获变量显示为(Hello)(there,)(neighoor)
}